---
title:  GNN 을 이용한 Movielens 데이터셋에서 Link prediction

excerpt: Recommendation System, Pytorch, torch-geometric  

toc : true
toc_sticky : true  

use_math: true

categories:
  - study
tags:
  - study
  - recsys
  - pytorch
  - torch-geometric
---

[Pytorch geometric](https://colab.research.google.com/drive/1xpzn1Nvai1ygd_P5Yambc_oe4VBPK_ZT?usp=sharing)
에서 Movielens 데이터셋을 이용한 GNN 튜토리얼을 제공하고 있길레 풀어보았다.

사용하는 모델은 GraphSAGE 이고, 수행하는 테스크는 Link Prediciton 이다.

# 1. Install

우선 필요한 패키지들을 설치한다.

```python
import torch
from torch import Tensor
print(torch.__version__)

# Install required packages.
import os
os.environ['TORCH'] = torch.__version__

!pip install torch-scatter -f https://data.pyg.org/whl/torch-${TORCH}.html
!pip install torch-sparse -f https://data.pyg.org/whl/torch-${TORCH}.html
!pip install pyg-lib -f https://data.pyg.org/whl/nightly/torch-${TORCH}.html
!pip install git+https://github.com/pyg-team/pytorch_geometric.git
```


# 2. Download dataset

데이터셋을 다운받는다, movielens 100k 데이터셋이며 상호작용 10만 , 유저 600명 , 아이템 9000개 인 데이터셋이다.

```python
from torch_geometric.data import download_url, extract_zip

url = 'https://files.grouplens.org/datasets/movielens/ml-latest-small.zip'
extract_zip(download_url(url, '.'), '.')

movies_path = './ml-latest-small/movies.csv'
ratings_path = './ml-latest-small/ratings.csv'
```

# 3. Preprocessing

다운로드 받은 데이터를 전처리한다. 

```python
from torch_geometric.data import download_url, extract_zip

url = 'https://files.grouplens.org/datasets/movielens/ml-latest-small.zip'
extract_zip(download_url(url, '.'), '.')

movies_path = './ml-latest-small/movies.csv'
ratings_path = './ml-latest-small/ratings.csv'

movies.csv:
===========
   movieId                                       genres
0        1  Adventure|Animation|Children|Comedy|Fantasy
1        2                   Adventure|Children|Fantasy
2        3                               Comedy|Romance
3        4                         Comedy|Drama|Romance
4        5                                       Comedy

ratings.csv:
============
   userId  movieId
0       1        1
1       1        3
2       1        6
3       1       47
4       1       50

```

이 예제에서는 평점에 따른 차이는 무시하고, 연결 여부만을 보았다.

이제 이 데이터를 그래프 구조로 만들어야 한다. 이 부분은 사람마다 만들기 나름인 것 같은데

일단 예제에서 제시하는 코드는 다음과 같다.

```python
# Load the entire ratings data frame into memory:
ratings_df = pd.read_csv(ratings_path)

# Create a mapping from unique user indices to range [0, num_user_nodes):
unique_user_id = ratings_df['userId'].unique()
unique_user_id = pd.DataFrame(data={
    'userId': unique_user_id,
    'mappedID': pd.RangeIndex(len(unique_user_id)),
})
print("Mapping of user IDs to consecutive values:")
print("==========================================")
print(unique_user_id.head())
print()
# Create a mapping from unique movie indices to range [0, num_movie_nodes):
unique_movie_id = pd.DataFrame(data={
    'movieId': movies_df.index,
    'mappedID': pd.RangeIndex(len(movies_df)),
})
print("Mapping of movie IDs to consecutive values:")
print("===========================================")
print(unique_movie_id.head())

# Perform merge to obtain the edges from users and movies:
ratings_user_id = pd.merge(ratings_df['userId'], unique_user_id,
                            left_on='userId', right_on='userId', how='left')
ratings_user_id = torch.from_numpy(ratings_user_id['mappedID'].values)
ratings_movie_id = pd.merge(ratings_df['movieId'], unique_movie_id,
                            left_on='movieId', right_on='movieId', how='left')
ratings_movie_id = torch.from_numpy(ratings_movie_id['mappedID'].values)

# With this, we are ready to construct our `edge_index` in COO format
# following PyG semantics:
edge_index_user_to_movie = torch.stack([ratings_user_id, ratings_movie_id], dim=0)
assert edge_index_user_to_movie.size() == (2, 100836)

print()
print("Final edge indices pointing from users to movies:")
print("=================================================")
print(edge_index_user_to_movie)

Mapping of user IDs to consecutive values:
==========================================
   userId  mappedID
0       1         0
1       2         1
2       3         2
3       4         3
4       5         4

Mapping of movie IDs to consecutive values:
===========================================
   movieId  mappedID
0        1         0
1        2         1
2        3         2
3        4         3
4        5         4

Final edge indices pointing from users to movies:
=================================================
tensor([[   0,    0,    0,  ...,  609,  609,  609],
        [   0,    2,    5,  ..., 9462, 9463, 9503]])
```

# 4. Graph Creation

이제 torch_geometric 을 이용하여 hetrogeneous 한 그래프 데이터 구조를 만들어 낼 것이다. <br> 
이것은 여러 타입의 노드와 엣지를 가진 그래프를 의미한다. <br>
우리는 그래프의 노드들을 샘플링 할 것이기 때문에 먼저 노드들에 id 를 부여해주고, <br>
그런 다음 노드 간에 양방향 message 를 보내기 위해서 reverse edge 를 그래프에 추가해 줄 것이다. <br>
코드는 다음과 같다.

```python
from torch_geometric.data import HeteroData
import torch_geometric.transforms as T

data = HeteroData()

# Save node indices:
data["user"].node_id = torch.arange(len(unique_user_id))
data["movie"].node_id = torch.arange(len(movies_df))

# Add the node features and edge indices:
data["movie"].x = ...  # TODO
data["user", "rates", "movie"].edge_index = ...  # TODO

# We also need to make sure to add the reverse edges from movies to users
# in order to let a GNN be able to pass messages in both directions.
# We can leverage the `T.ToUndirected()` transform for this from PyG:

# TODO:
raise NotImplementedError

print(data)

assert data.node_types == ["user", "movie"]
assert data.edge_types == [("user", "rates", "movie"),
                           ("movie", "rev_rates", "user")]
assert data["user"].num_nodes == 610
assert data["user"].num_features == 0
assert data["movie"].num_nodes == 9742
assert data["movie"].num_features == 20
assert data["user", "rates", "movie"].num_edges == 100836
assert data["movie", "rev_rates", "user"].num_edges == 100836
```

여기부터 빈칸 채우기가 나오는데 공식문서의 설명과 코드 주석을 보고 TODO 를 채운다. <br>
[HetroData 클래스의 설명을 보면](https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.HeteroData.html#torch_geometric.data.HeteroData) 이렇게 나와 있다.

>HeteroData tries to mimic the behavior of a regular nested Python dictionary. In addition, it provides useful functionality for analyzing graph structures, and provides basic PyTorch tensor functionalities.

```python
from torch_geometric.data import HeteroData

data = HeteroData()

# Create two node types "paper" and "author" holding a feature matrix:
data['paper'].x = torch.randn(num_papers, num_paper_features)
data['author'].x = torch.randn(num_authors, num_authors_features)

# Create an edge type "(author, writes, paper)" and building the
# graph connectivity:
data['author', 'writes', 'paper'].edge_index = ...  # [2, num_edges]
```

파이썬 딕셔너리처럼 활용할 수 있다는 부분이 중요한 것 같다. 노드와 엣지를 생성하는 예시 코드가 있으므로 <br>
이것을 보고 우리 문제의 첫 부분을 채울 수 있다. 그 다음 부분은 transforms 클래스를 활용하라고 되어 있다. <br>
이를 통해 생성한 데이터를 커스터마이즈 할 수 있다. 이 예제에선 T.ToUndirected 메소드를 사용한다. <br>
Hetrogeneous 그래프가 message passing 을 하기 위해선 이렇게 해야하는 것 같다. <br>
(물론 아닌 경우도 있겠지만.)
